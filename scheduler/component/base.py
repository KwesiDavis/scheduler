import os, logging
from multiprocessing import Manager
import scheduler.util.plumber

def isThreaded(graph, processName):
    '''
    Determine weather the given component should be started as a system-thread 
    or a system-process.
    
    Parameters:
        graph - A graph of components connected together by data ports
        processName - The name of a worker process
    Returns:
        'True' if the given worker process should run in a thread or else 'False'.
    '''
    retval = False
    # Use leading and trailing underscores to set default threading status
    try:
        componentName = graph['processes'][processName]['component']
        retval = componentName.startswith('_') and componentName.endswith('_')
    except KeyError:
        pass
    return retval

def isFramework(processName):
    '''
    Determine weather the given process was specified in the users original 
    graph file or auto-generated, for some reason, by the framework.
    
    Parameters:
        processName - The name of a process.
    Returns:
        'True' if the given process was auto-generated by the framework
        or else 'False'.
    '''
    return processName.startswith('*') and processName.endswith('*') 

def internalEvent(core, eventType):
    '''
    Sends a message (or event), of the given type, out of the 'events'
    port of a process.  These messages allow internal framework events to 
    propagate through the graph like any other information packet.   
    Note: An event can block the execution of a process, if it has been 
          configured to do so (and must then be unblocked by the receiver
          of the event).
    
    Parameters:
        core - a dictionary of internal framework attributes
        eventType - a string representing a special internal event
    '''
    eventSender = core['name']
    # Construct an event (or notification message).
    event  = {'sender' : eventSender,
              'type'   : eventType}
    # Does this event have framework-blocking powers?
    config = core['getConfig']()
    isEventBlocking = False
    try:
        isEventBlocking = config['blocking'][eventType]
    except TypeError:
        # No config data for this process
        pass
    except KeyError:
        # No blocking info in this config data
        pass
    # If blocking enabled for the given event type attach an object to the out 
    # going message that allows a recipient to unblock this process. 
    if isEventBlocking:
        event['blocker'] = Manager().Event()
        core['setData']('events', event)
        event['blocker'].wait()
    # Blocking in not enabled so just send the event.
    else:
        core['setData']('events', event)
    
def fxn(core, inports, outports, fxn, wait=True):
    '''
    This is canonical framework functionality for a generic component:
    * handle Pipe file descriptor leak
    * setup API to get and set data on named ports
    * wait for data to arrive on in-ports
    * run component logic
    * wait for EOF on in-ports
    * close all in-ports and out-ports
    
    Parameters:
        core - a dictionary of internal framework attributes
        inports - the named input ports
        outports - the named output ports
        fxn - the component logic 
        wait - When 'True', the default, wait for data to arrive on all
                      in-ports before starting the process. If 'False', start 
                      as soon as any data arrives on any in-port.  
    '''
    # Log that this component has started
    logging.debug('BGIN: {name}'.format(name=core['name']))
    
    
    FIRST_CONN = 0
    state      = {}
    # round robin support
    state['set data count'] = {}
    for portName in outports.keys():
        state['set data count'][portName] = [ 0, len(outports[portName]) ]
    # Close un-used end of Pipe connection
    processName = core['name']
    scheduler.util.plumber.closeByProcess(core['leak'], processName)
    # Create helper functions
    def lenAtFxn(portName, inport=True):
        '''
        Gets the number of components connected to a single port.
        
        Parameters:
            portName - The name of the port to query.
            inport - When 'True', the default, the given port name is assumed
                     to be an input port, otherwise it's checked as an out-port.
                     
        Returns:
            An 'int' representing the number of connections attached to the 
            given port.
        '''
        if inport:
            return len(inports[portName])
        return len(outports[portName])
    def getDataAtFxn(connIndex, inportName, block=True):
        '''
        Get the next information packet that arrives at the given in-port name
        from the one connection (of many) associated with the given connection
        index.  If there is no data at the port, this method blocks until data
        arrives, unless the option poll the port is specified.  In the polling
        case, it is non-blocking and an exception is thrown when there is no 
        data.   
        
        Parameters:
            connIndex - An index representing one, of potentially many, 
                        connections on the given in-port name.
            inportName - The name of the in-port to get data from. 
            block - When 'True', the default, this method blocks until data
                    arrives, on the given in-port name, from the connection 
                    associated with the given connection index. If 'False',
                    the method returns immediately with data or it throws an
                    exception if data has not arrived yet.
                    
        Returns:
            The data sitting on the given in-port name, from the connection 
            associated with the given connection index.
            
        Exceptions:
            Throws an 'ValueError' when blocking is disabled and there is no data
            available on the given in-port name, from the connection associated
            with the given connection index.
        '''
        try:
            conn = inports[inportName][connIndex]
        except KeyError, e:
            # Trying to get data from an unconnected in-port
            logging.info('Data requested from an unconnected port: {proc}.{port}'.format(proc=core['name'],
                                                                                         port=inportName))
            raise e
        # Don't waste time waiting for recv() to return with data. Throw an 
        # error if there is nothing available, yet...
        if not block:
            if not conn.poll():
                raise ValueError('In-port {proc}.{port} not ready for recv()'.format(proc=core['name'],
                                                                                     port=inportName))
        data = conn.recv()
        logging.debug('RECV: {proc}.{port} = {data}'.format(data=str(data),
                                                            proc=core['name'],
                                                            port=inportName))
        return data
    def getDataFxn(inportName, block=True):
        '''
        Assuming the given in-port name has only one connection, get the next 
        information packet that arrives at that port.  If there is no data at
        the port, this method blocks until data arrives.   
        
        Parameters:
            inportName - The name of the in-port to receive data from.
            block - When 'True', the default, this method blocks until data
                    arrives, on the given in-port name. If 'False', the method
                    returns immediately with data or it throws an exception if
                    data has not arrived yet.
            
        Returns:
            The data sitting on the given in-port name.
        '''
        connCount = len(inports[inportName])
        if connCount > 1:
            logging.info('In-port {proc}.{port} has {count} connections, but only one requested.'.format(proc=core['name'],
                                                                                                         port=inportName,
                                                                                                         count=connCount))
        return getDataAtFxn(FIRST_CONN, inportName, block=block)
    def setDataFxn(outportName, data):
        '''
        Send the given information packet (or data object) through the given
        out-port. If there are multiple connections, on that single port, load
        balance across all connections by sending data to the connection that
        has waited the longest to receive data. 
        Note: When there are multiple connections, data is *not* copied and 
              broadcast across all connected targets.   
        
        Parameters:
            outportName - The name of the out-port to send data to.
            data - an information packet (or data object)
        '''
        logging.debug('SEND: {proc}.{port} = {data}'.format(data=str(data),
                                                            proc=core['name'],
                                                            port=outportName))
        try:
            # Load balance across out connection (per port) 
            numSetCalls, numConnections = state['set data count'][outportName]
            roundRobinIndex = numSetCalls % numConnections  
            conn = outports[outportName][roundRobinIndex]
            state['set data count'][outportName][0] += 1
        except KeyError:
            # Trying to send data to an unconnected out-port
            logging.info('Data ({data}) sent to unconnected port: {proc}.{port}'.format(data=str(data),
                                                                                        proc=core['name'],
                                                                                        port=outportName))
            return
        conn.send(data)
    def getConfigFxn():
        '''
        Get the configuration data for this process.   
        
        Returns:
            Configuration data in whatever format the process expects.
            Note: Configuration data can be specified in the graph file as 
                  metadata on a process.
            Example:
                  { processName : { 'component' : componentName,
                                    'metadata'  : { 'config' : <whatever format> } } }
        '''
        return core['metadata'].get('config', None)
    # Make helper functions available to process
    core['getDataAt'] = getDataAtFxn
    core['getData']   = getDataFxn
    core['setData']   = setDataFxn
    core['getConfig'] = getConfigFxn
    core['lenAt']     = lenAtFxn
    
    # Collect all in-port connections
    inportConns = []
    for inportName in inports.keys():
        for conn in inports[inportName]:
            inportConns.append(conn)
    # Wait for data to arrive at...
    if wait:
        # ...*all* in-ports
        while not all([conn.poll() for conn in inportConns]):
            continue
    else:
        # ...*any* single in-port connection
        while not any([conn.poll() for conn in inportConns]):
                continue
    # Notify listeners that this process is ready to execute
    internalEvent(core, 'ReceivedAllInputs')

    # Run the component logic
    fxn(core)
    # Close all connections
    for ports in [inports, outports, core.get('ports', {})]:
        for portName, connList in ports.items():
            for conn in connList:
                logging.debug('CONN: [{pid}] On exit, process "{proc}" closed "{proc}.{port}".'.format(pid=os.getpid(), proc=core['name'], port=portName))        
                conn.close()
    # Log that this component has finished       
    logging.debug('END : {name}'.format(name=core['name']))